<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vimer.Me]]></title>
  <subtitle><![CDATA[基础·极致·分享]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://vimer.me/"/>
  <updated>2016-01-23T13:04:41.984Z</updated>
  <id>http://vimer.me/</id>
  
  <author>
    <name><![CDATA[vimer.me]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[疯狂创业路（六）：不合适就是不合适]]></title>
    <link href="http://vimer.me/2015/10/startup-6-inappropriate-is-inappropriate/"/>
    <id>http://vimer.me/2015/10/startup-6-inappropriate-is-inappropriate/</id>
    <published>2015-10-18T16:35:05.000Z</published>
    <updated>2015-11-23T05:53:18.000Z</updated>
    <content type="html"><![CDATA[<p>10.14号，周四，劝退了一位并肩了3个月的兄弟。这位兄弟做了一手好菜，人也不错，和团队成员相处融洽，但是在试用过程中发现和公司的职位要求有点距离，可能他在其他地方会有更好的发展，为了不耽误双方，就让去寻找更好的得方发展了。在劝退的那天，他租得隔间房被政府抢拆了，还记得那晚他发的朋友圈：”福无双至祸不单行~抬头的一片天，是男儿的一片天，是追梦的少年。 “，加油。</p>
<h3 id="辞职和辞退">辞职和辞退</h3>
<p>“不好意思，跟你提件事，我想离职…” ，我们很多人都是经历这个过程的，大部分都跳槽过很多公司，如果有下家，感觉跳槽是件很轻松的事，根本很少不考虑目前公司感受。从心理学角度分析：感觉提出离职是个很光荣的事（谁让你不器重我，此处不留爷，自有留爷处…）。</p>
<p>“不好意思，你不符合我们要求，你被辞退了…” ，对于这句话我相信大部分人都会很陌生，因为大部分人是很少被辞退的，就算被辞退，公司leader也很少这么直接，从大部分最初的管理者来说，劝退总是件开口比较难的事，尤其小公司，平时几个人相处比较好，你既要从公司角度考虑，又要还是保持朋友关系，好聚好散。</p>
<p>其实说到这，是想说明任何一个人都要为自己负责，为自己正在做的事负责，也要为所在的公司负责，这就是做人。从公司角度，有一个原则是不能被破的：不合适就是应该辞退，不合适就是不合适。<br><a id="more"></a></p>
<h3 id="用人原则">用人原则</h3>
<p>从“创业”公司角度，一个合格的员工，必须具备：</p>
<ul>
<li>做事的态度</li>
<li>不能把和工作无关的负能量带给他人</li>
</ul>
<p>这两个可以看作是原则问题，一经发现经过提醒不悔改必须辞退。</p>
<p>有了上面两个基本原则，再去观察这个员工是否有足够的热情投入到事业上来，这是评判一个员工是否热爱自己工作的一个因素，或者可以说真正能把自己而工作。可以说是非常好的加分项。</p>
<p>在整个过程中，要用最短的时间，给足他压力考验他与职位要求是否有距离，如果距离太大，需要过多培养成本，及时劝退。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>10.14号，周四，劝退了一位并肩了3个月的兄弟。这位兄弟做了一手好菜，人也不错，和团队成员相处融洽，但是在试用过程中发现和公司的职位要求有点距离，可能他在其他地方会有更好的发展，为了不耽误双方，就让去寻找更好的得方发展了。在劝退的那天，他租得隔间房被政府抢拆了，还记得那晚他发的朋友圈：”福无双至祸不单行~抬头的一片天，是男儿的一片天，是追梦的少年。 “，加油。</p>
<h3 id="辞职和辞退">辞职和辞退</h3>
<p>“不好意思，跟你提件事，我想离职…” ，我们很多人都是经历这个过程的，大部分都跳槽过很多公司，如果有下家，感觉跳槽是件很轻松的事，根本很少不考虑目前公司感受。从心理学角度分析：感觉提出离职是个很光荣的事（谁让你不器重我，此处不留爷，自有留爷处…）。</p>
<p>“不好意思，你不符合我们要求，你被辞退了…” ，对于这句话我相信大部分人都会很陌生，因为大部分人是很少被辞退的，就算被辞退，公司leader也很少这么直接，从大部分最初的管理者来说，劝退总是件开口比较难的事，尤其小公司，平时几个人相处比较好，你既要从公司角度考虑，又要还是保持朋友关系，好聚好散。</p>
<p>其实说到这，是想说明任何一个人都要为自己负责，为自己正在做的事负责，也要为所在的公司负责，这就是做人。从公司角度，有一个原则是不能被破的：不合适就是应该辞退，不合适就是不合适。<br>]]>
    
    </summary>
    
      <category term="venture-road" scheme="http://vimer.me/categories/venture-road/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[疯狂创业路（五）：Done is better than perfect]]></title>
    <link href="http://vimer.me/2015/09/startup-5-Done-is-better-than-perfect/"/>
    <id>http://vimer.me/2015/09/startup-5-Done-is-better-than-perfect/</id>
    <published>2015-09-14T12:24:54.000Z</published>
    <updated>2015-11-23T05:53:23.000Z</updated>
    <content type="html"><![CDATA[<p>一直想写疯狂创业路的第五篇，却总是被各种琐事闯入，其实创业也就是这样，生活不可能是有条不紊的。</p>
<p>听着《Better man》整理这段时间的思绪… 12号早上为第一次参加上海国际马拉松进行了一次16KM的长跑训练，希望对自己的韧性、耐性进行一次挑战。</p>
<h3 id="团队">团队</h3>
<p>还是先从团队说起，经过一段时间拿捏，研发团队这块算是有点小有起色，什么叫小有起色？大家能把更多的注意力集中在产品和技术，而不是不断的招人，面试… 不过，这方面开始我承认对团队这块管理经验有所欠缺，还好，自己调整的也比较快，你要问我经验， 两个字: 人性 ，四个字：换位思考 。</p>
<p>不过问题还是很多，一方面：血液还是要经常调整，不适合的就是不适合，但是适合的就要让他留下来（这是对我的一个挑战，以前一个公司的leader，被同事说这不好，那不好，现在反过来思考，其实真正运营好一个公司，不可能不得罪人，很多人觉得你不好，可能只是他只是从自己的角度看了问题，而一个公司的管理者，更多时候是在平衡，而不是求完美） 招人不易，招适合的人更不易，下面一步棋得下的稳些。另一方面：整体拼劲还远不够，产品迭代速度有点慢。这两个方面是接下来着重加强的。<br><a id="more"></a></p>
<p>执行力很重要，其他次之，如果你的团队中有一个成员点子非常多，看起来是好事，但是对于创业就要小心了，点子如果很多，很容易导致团队分心，导致最后什么都没有做出来。创业者专注很重要。</p>
<blockquote>
<p>另外强调一点：不管任何时候，任何人都要分配平衡,这是创业的基本法则，切忌有分配不一致（大家能聚一起做事不易，不要因为这些事而影响大家）。</p>
</blockquote>
<h3 id="任务管理">任务管理</h3>
<p>这里要感谢下Teambition，强烈推荐。</p>
<p> <img src="http://ww3.sinaimg.cn/large/744e593bgw1ew24dc3jz5j214i0kowh8.jpg" alt="Task"></p>
<p>正常来说，我把任务版分成近期任务，本周任务，今日·未完成，今日·进行中，已完成</p>
<ul>
<li>近期任务： 所有突发奇想，或者拍脑袋的任务全部列在这边</li>
<li>本周任务:   本周需要完成的任务，周会中分工</li>
<li>今日·未完成：当日需要完成的任务，每日晨会中安排</li>
<li>今日·进行中：正在进行的任务，每人只有一个正在进行的任务</li>
<li>已完成：已经完成的任务，用于后期检查)]</li>
</ul>
<p>一方面此任务板能达到团队成员之间互相push的目的，另一方面,大家可以互相看到成员正在做什么，心里可以平衡任务的状态。</p>
<p>另外，这边有个注意点需要考虑，对于拍脑袋提出的需求可以先布置到近期任务中，如果比较紧急，那么必须和成员商量提前，其他任务切换到近期任务板，或者加班完成。</p>
<h3 id="产品">产品</h3>
<p>Done is better than perfect， 这是Facebook的标语，完成比完美更重要，从产品角度看，首先一个产品切忌一开始就想把它打造非常完美，大公司如此，小公司更应该如此，尽量避免死扣一些细节问题，为一些不必要的细节花太多时间。其次，切忌多方领导做产品，任何一款产品只能一个人主导，其他人只是建议。</p>
<p>另外补充一句：好多做技术的朋友创业的经过的时候，会说一句：运营非常重要，甚至最重要，我这里强调一点：运营是很重要，但是好的产品才是用户留存的关键，留存才是产品的王道。</p>
<p>对于一个开始主要切企业的产品，有一个问题是用户过于分散，就像俊元说的：如果你投一个广告，很多企业都能看到，那么这个过于理想了，永远不会有，所以永远是让我们的用户（企业）用完了我们的产品，然后如果觉得好，才去向外推荐，所以归结起来还是产品问题，toB的产品，品牌其实更重要，如上面所说，只有口碑好了，用户才会帮你推荐，会大大减少你额外的销售成本。</p>
<p>产品是最核心的东西，产品上对于销售的引导，远远比我们冲出去好得多。</p>
<h3 id="技术，数据时代的变化">技术，数据时代的变化</h3>
<p>引用舍恩伯格一个例子:<br>“大家应该知道jawbone，这个手环的制造商，他们也在搜集这些数据，比如你起床、运动频率等等数据。我们也可以搜集数据，然后进行分析。去年加州发生了地震，在加州有很多人都佩戴jawbone，他们不断的搜集自己的数据，而且地震发生的时候，是在午夜，他们搜集的数据有一个区县，可以看到这里用户的数量，他们戴着jawbone手环，在晚上三点钟的时候，应该是大家都在睡觉了，但是突然地震发生了，然后我们看到这个峰值，因为地震发生的时候，大家肯定要从床上跳下来逃生，大家就看到了这样一个曲线变化。为什么这个数据特别的重要？因为不同的颜色代表不同的城市。就告诉大家这个地震的程度有多少，在不同地区，这个地震是大还是小。jawbone的用户他们很好的捕捉到了地震的数据，甚至比政府做得还要好。甚至比政府地震仪捕捉到的数据做得更好。jawbone就想了，我们不仅可以来预测地震，因为它现在已经搜集到了这些地震的信息。但是实际上这些大数据给我们提供了一个现代平台，大家可能听说过一年多前谷歌收购了nest，它是生产恒温计的。其中一个创始人我也认识。这个恒温计是调节你在家里环境的温度，谷歌收购了这个品牌，他们花了三十亿美金投资到这个公司，大家就想了，30亿，就买了一个恒温计的制造商，真的吗？值不值这个钱？他们并不了解谷歌的想法，这实际上是一个智能恒温计，这个恒温计可以记得你整个温度的调节，它可以记忆你这一天之中，哪个时间段是调节了温度，因此它就可以捕捉这些数据，了解你的行为，不论是你在家里，回到家的时候，是你想要温度上升，或者是温度下降，它在了解你的习性，了解了这个习性之后，数据发送到总部。那么现在谷歌就获得了很多人在家里的温度的情况，而且在哪个时间段需要什么样的温度，这些数据都搜集到了，大家可以想象一下这些数据的价值有多少。这样大家可以通过这样的方式来进行能源保护，节省能源，比如说你可以采取一些环保的措施，这也是为什么谷歌收购了这个品牌。它实际上提供了一个全新的平台。”</p>
<p>No Data, No future. 如何利用现有的数据，让数据更好的服务于你的用户，是我们正在做的。</p>
<h3 id="沟通">沟通</h3>
<p>在我生日那天参加了一期沟通方面的课程，受益匪浅。有几点非常非常赞同：</p>
<ul>
<li>重复别人的话，让别人受重视</li>
<li>事实容易产生共识，意见容易产生争议，所以多论述事实，而不是意见</li>
<li>扬他人之长，避他人之短</li>
<li>先用别人喜欢的风格来进行沟通</li>
<li>正确的行为需要得到必要的反馈</li>
<li>激励成员时找准他真正的需求</li>
<li>一个成年人他说这个话多半是因为他得经历，人得经历不同，看事的角度也不同，没有必要证明他是错误的</li>
</ul>
<p>最后说两件值得开心的事，一个是：公司在2015创新创业大赛中踏入国家赛。另外一个是：公司整体进入统一战线期，这是相对于以前摸索方向，不断试错非常好的一件事。</p>
<p>不管怎么样，加油，每一天都是新的一天。</p>
<p><img src="http://ww4.sinaimg.cn/large/744e593bgw1ew26tpsdw3j20zk0qo40t.jpg" alt="NewDay"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直想写疯狂创业路的第五篇，却总是被各种琐事闯入，其实创业也就是这样，生活不可能是有条不紊的。</p>
<p>听着《Better man》整理这段时间的思绪… 12号早上为第一次参加上海国际马拉松进行了一次16KM的长跑训练，希望对自己的韧性、耐性进行一次挑战。</p>
<h3 id="团队">团队</h3>
<p>还是先从团队说起，经过一段时间拿捏，研发团队这块算是有点小有起色，什么叫小有起色？大家能把更多的注意力集中在产品和技术，而不是不断的招人，面试… 不过，这方面开始我承认对团队这块管理经验有所欠缺，还好，自己调整的也比较快，你要问我经验， 两个字: 人性 ，四个字：换位思考 。</p>
<p>不过问题还是很多，一方面：血液还是要经常调整，不适合的就是不适合，但是适合的就要让他留下来（这是对我的一个挑战，以前一个公司的leader，被同事说这不好，那不好，现在反过来思考，其实真正运营好一个公司，不可能不得罪人，很多人觉得你不好，可能只是他只是从自己的角度看了问题，而一个公司的管理者，更多时候是在平衡，而不是求完美） 招人不易，招适合的人更不易，下面一步棋得下的稳些。另一方面：整体拼劲还远不够，产品迭代速度有点慢。这两个方面是接下来着重加强的。<br>]]>
    
    </summary>
    
      <category term="venture-road" scheme="http://vimer.me/categories/venture-road/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[疯狂创业路（四）：铁打的营盘，流水的'兵']]></title>
    <link href="http://vimer.me/2015/05/startup-4-Iron-barracks-water-the-soldiers/"/>
    <id>http://vimer.me/2015/05/startup-4-Iron-barracks-water-the-soldiers/</id>
    <published>2015-05-30T14:54:42.000Z</published>
    <updated>2015-11-23T05:53:27.000Z</updated>
    <content type="html"><![CDATA[<p>最近对这句话”铁打的营盘，流水的兵”理解越来越深刻，并不是因为这句话本身有多难理解，而是理解的角度会随着你正在做的事情越趋深刻。</p>
<h3 id="浮躁的现状">浮躁的现状</h3>
<p>公司人员流动一直很频繁，这应该不是只有我遇到的问题，大部分公司都会遇到，我有很多朋友也在创业，招不到人，应该说招不到合适靠谱的人，员工频繁流动，各种抱怨。但这又能怪谁，当大面积出现类似问题时，是应该反思是否是公司的问题了。公司的事我会娓娓道来，除了公司问题，还有很多其他现象，这里我先不扯远，我就说下我真实看到的现状。</p>
<p>我不清楚现在的人为什么如此浮躁。</p>
<a id="more"></a>
<p>1.之前iOS人员一直缺着，花了大量时间去招人，面了很多人，我发现大部分做iOS开发的都是快餐式培训出来的(补充一句,这里我没有说培训出来的不好)，而是很多人为了追求高薪，跨着专业去培训，连操作系统原理、数据结构、计算机网络都没搞懂，培训了3-4个月以为就可以拿高薪了，但是他们的以为还真有企业把他们的“梦想”变为现实。之所以这样，现今移动互联网创业大潮，导致做事的人少了，产品赶着要上架，又没人做，就死马当活马医了。更遇到很多刚刚培训出来的谎称自己已经有1年工作经验，还有自己是自学的，当我问到你是怎么自学的时候，就支支吾吾的了。做计算机这一行，并不是你学个计算机语言就可以搞定的事，如果你并不是真真喜欢这一行，纯粹的为了钱，完全不可能在这一行立足。</p>
<p>2.在招聘会的时候遇到一个作品还可以的设计师，然后也一起见面吃饭聊了也还不错，说好毕业后要来公司的，但是毕业后的一段时间内，发现无踪影了，一声招呼都不说，我们的一个产品还等着他开工。我在想 不管你不来的理由有千种，至少应该和我们打个招呼吧，这样我们会去另外想办法招人。</p>
<h3 id="聚集一批疯子">聚集一批疯子</h3>
<p>“让所有成员都可以看到就算现在做的事情失败，也没什么大不了的，因为只要团队在，再重新来又如何 ” 这是一个铁打营盘核心，但是打造这样的营盘何其容易，我们都知道这个社会是个现实社会，人现实，啥都现实，一个创业公司何来的凝聚力能让一帮疯子聚在一起 ? 暂不谈一群价值观相同的疯子，就说说正常来工作的吧，现在工作的人不外乎两类: 刚毕业的大学生和工作多年一直跳槽的人，这两类都有很强的差异性: </p>
<p>1.先说说刚毕业的大学生，这里只说多数情况，刚毕业的大学生，经验各方面都是不足的，创业公司招这些人其实成本还是挺大的，里面涉及很多的培养成本，但是也有很多能力很不错，基础很好，稍微培养下定是个不错的苗子。如果缘分好能遇到不错的久把他留下吧，其他的可以完全不用考虑，因为里面包含着各种不靠谱。</p>
<p>2.再说说工作经验还可以不断跳槽的人，尤其工作1-2年跳了很多次槽的，跳槽的原因无外乎两种原因，薪资问题或做的不爽。这里我不论具体跳槽原因的细节，如果创业公司想通过社招招来一批还不错的人，真是想当然了。 但是大部分时候真是没办法，总会遇到合适的，所以需要花大时间的面试。说到面试这里就又有Hire slow or Hire Fast的问题了.</p>
<h3 id="“Hire_slow，Fire_Fast”_OR_“Hire_Fast，Fire_Fast”">“Hire slow，Fire Fast” OR “Hire Fast，Fire Fast”</h3>
<p>Hire这一层是不包含试用期的，真正录用只有成为正式成员的时候，所以这里就不存在Hire slow和Hire Fast的问题了，三个月的试用期足够验证这个人是否合适了。一定要增加Hire难度，Fire的时候得速度。这一点得坚信不疑。</p>
<h3 id="人要沉淀，团队更要沉淀">人要沉淀，团队更要沉淀</h3>
<p>提起这个事，让我想到自己为了有块地方可以安静的深入研究存储辞职考北大信科，那1年多全部时间泡在图书馆里，有朋友事后对我说了句: 你值得吗，那年的时间基本浪费了吧。我心平气和带着微笑说：首先我做一件事只要不后悔就行，其次不管结果如何，对我来说，这个过程让我沉淀了很多，就比方说我的基础又扎实了不少，我一向认为，基础决定高度。这个就像你学任何东西，欲速则不达，那1年让我学会为了沉淀，让我有足够的时间反思。才让我现在安静下来专注做点事情。</p>
<p>人要沉淀，团队更要沉淀，这里就是在说到 “铁打的营盘，流水的兵”，用在创业公司尤其适合，什么是铁打的营盘 ？我认为在创业团队代表的就是种团队价值观及精神和制度，团队的成员是不停的流动的，毕竟做出一件成功的事情，必定是拥有为共同的价值观而奉献的一群疯子。一个靠谱的团队从0到1不可能始终是同一群人，来来往往，而在这过程中真正去铸造一个铁打的营盘。一个企业的文化大部分都是由几个核心创始人决定的，他们的想法，他们的执行力，他们的思维，来决定公司走向。整个团队打磨的过程中，自然而然很多好的东西会被沉淀下来，如果你不知道什么是公司的文化，你应该去一些公司去学习下，比如Google的“工程师文化”。</p>
<p>沉淀的东西不仅仅是软性的东西，还有很多硬性的，从技术角度看，如技术文档，代码规范，适合自己业务方面的框架等等。</p>
<h3 id="创业公司不易，慎重选择">创业公司不易，慎重选择</h3>
<p>大部分创业公司都还处在没有风投阶段，烧的是自己的钱，大部分都不是土豪，我曾待过一个创业公司，老板很多自己的东西抵押付工资，诸多不易。所以我真的很希望求职者真诚认真的对待这些创业公司。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近对这句话”铁打的营盘，流水的兵”理解越来越深刻，并不是因为这句话本身有多难理解，而是理解的角度会随着你正在做的事情越趋深刻。</p>
<h3 id="浮躁的现状">浮躁的现状</h3>
<p>公司人员流动一直很频繁，这应该不是只有我遇到的问题，大部分公司都会遇到，我有很多朋友也在创业，招不到人，应该说招不到合适靠谱的人，员工频繁流动，各种抱怨。但这又能怪谁，当大面积出现类似问题时，是应该反思是否是公司的问题了。公司的事我会娓娓道来，除了公司问题，还有很多其他现象，这里我先不扯远，我就说下我真实看到的现状。</p>
<p>我不清楚现在的人为什么如此浮躁。</p>
]]>
    
    </summary>
    
      <category term="venture-road" scheme="http://vimer.me/categories/venture-road/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态分支预测]]></title>
    <link href="http://vimer.me/2015/05/dynamic-branch-prediction/"/>
    <id>http://vimer.me/2015/05/dynamic-branch-prediction/</id>
    <published>2015-05-10T04:24:29.000Z</published>
    <updated>2015-11-23T05:57:39.000Z</updated>
    <content type="html"><![CDATA[<p>说起这个话题也挺有意思，上周五我在公司技术分享的时候，在最末提到一个问题: </p>
<p>为什么排序过的数据在遍历的时候速度更快 ?</p>
<p>这里我拿出很久之前在Stack Overflow上火车在行驶的过程中的例子</p>
<a id="more"></a>
<p><img src="http://ww4.sinaimg.cn/large/744e593bgw1erz071og68j21520jp7b8.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erz08s1yjaj21540ih7bj.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erz08s1yjaj21540ih7bj.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/744e593bgw1erz0a5681wj215a0mh7dc.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erz0bo194hj214y0j7tel.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erz0dxmakaj214r0lun4t.jpg" alt=""></p>
<p>这里就有伙伴提出问题了，既然靠猜，火车如果发现目的地不是预期的，那么就说明猜错了，但是CPU怎么知道猜错了呢？ 这里就涉及到cpu的流水线.</p>
<p>比如一个分支代码: </p>
<pre>
<code class="C">
if (data[j] >= 128) {
    sum += data[j];
}
</code>
</pre>

<p>从高级语言层来看，这段代码是只能顺序执行的，必须先检测条件，才能执行条件对应的语句. 但是从CPU角度来看，却不是这样，CPU会把这几条语句分成多条指令，取个简单例子:</p>
<p><img src="http://ww1.sinaimg.cn/large/744e593bgw1erz14fsgxmj210b0cltc0.jpg" alt=""></p>
<p>为了提高CPU中存储器、译码等的效率，CPU可采取流水线方式，上面两条指令假设一个是判断指令，一个是预测指令。那么当判断指令取指时，预测指令什么都还没做，当判断指令译码时，预测指令才开始取指，当判断指令执行时预测指令开始译码，这个时候，判断指令要么true，要么false，如果true 说明预测的指令是对的，这样效率会很明显提高，反之如果是false，那么就要重新进行，并把 目标地址 缓存到一个存储器中。一直循环到最后，这样就很容易解释为什么排序过的程序遍历会更快了.</p>
<p>补充下测试代码:</p>
<pre>
<code class="C++">
int main()
{
        const unsigned arraySize = 32768;
        int data[arraySize];
        for (unsigned i = 0; i < arraySize; i++) {
                data[i] = std::rand() % 256;
        }
        //std::sort(data, data + arraySize);
        clock_t start = clock();
        long long sum = 0;
        for (unsigned i = 0; i < 100000; i++) {
                for (unsigned j = 0; j < arraySize; j++) {
                        if (data[j] >= 128) {
                                sum += data[j];
                        }
                }
        }
        double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC;
        std::cout << "time = "<< elapsedTime << std::endl;
        std::cout << "sum = " << sum << std::endl;
}
</double></code>
</pre>

<p>在不sort的情况下和sort情况下可分别测试下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起这个话题也挺有意思，上周五我在公司技术分享的时候，在最末提到一个问题: </p>
<p>为什么排序过的数据在遍历的时候速度更快 ?</p>
<p>这里我拿出很久之前在Stack Overflow上火车在行驶的过程中的例子</p>
]]>
    
    </summary>
    
      <category term="cpu" scheme="http://vimer.me/tags/cpu/"/>
    
      <category term="性能" scheme="http://vimer.me/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="tech" scheme="http://vimer.me/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[疯狂创业路（三）：从"速度与激情"看团队]]></title>
    <link href="http://vimer.me/2015/04/startup-3-from-fast-furious-Look-team/"/>
    <id>http://vimer.me/2015/04/startup-3-from-fast-furious-Look-team/</id>
    <published>2015-04-19T15:24:04.000Z</published>
    <updated>2015-11-23T05:53:31.000Z</updated>
    <content type="html"><![CDATA[<p>今晚是第二遍看速7，不仅被剧情吸引，更被这样的团队所吸引， 或许是因为看到团队成员中自己的影子。</p>
<p>近期一直在忙着招聘的事，说实话，这真是个非常花精力的事情，而且你必须投入进去，因为没人会帮你去做，况且别人认为合适的，自己却不一定觉得他合适. 因为你们之间看到的点和面都可能不一样, 我看重的是他的综合能力如何，潜力，是否在团队中起个重要的角色等，别人看到的是可能是经验如何，性价比是否高…<br><a id="more"></a><br>继续先说说招聘的这个事：<br>首先，不能因为自己非常忙而不去浏览简历，等被面试的人过来才发现简历上的不合适。这个对双方都是非常浪费时间的。这个浏览简历一定要着重自己找人标准去浏览. 所以创始人的价值观非常重要. 用自己的价值观招的人，肯定也会是类似的.  (这里插一句: 加入创业公司，一定要和老板好好聊聊，如果他的价值观和你不对路，不要加入.) </p>
<p>其次，虽说招聘渠道能招到非常满意的基本上在10%的概率以下，但在你还没有更好的渠道之前，这个必须坚持去做，有些人的确是可遇不可求，不要认为牛人不会去投简历什么的， 我见过自己身边很多朋友，由于没有伯乐发现，但是自己个人性格问题，还是会去投简历到企业，这种人可能会在面试的过程中才能去发现他牛逼的地方. </p>
<p>再次，说个题外话，公司招人，一定不要为了临时需要一个就招过来，然后隔段时间事情做完后，就把人开掉，这是非常不道义的，也不适合团队发展，这个时候应尽量去外包给其他公司或者个人。</p>
<p>最重要的是，在面试过程中遇到还不错的，怎么“”拿下他” 才是重点，尤其是在公司资金还特别寒碜的情况下，每个人遇到的情况不一样，从我自身来看，可以提炼出几个词: “诚”，“兴趣”，“融入”，“价值”。</p>
<p>说说团队效率问题：<br>说个发生在现实中的一个对白:<br>A: “他们怎么下班后就走了呢”.<br>B说：”我分配的事情事情做完了当然可以走了”,<br>A继续问:”那是不是分配的任务还不够多?”<br>B反问:”难道你非要他们天天加班，你才满意哈.” ….</p>
<p>主要想说一点，每个人都想打造一个凝聚力很强的团队，但是实际上结果却是一个诚惶诚恐为你打工的团队。大部分时候都要从质去考虑事情，而不是量，无论从长期还是短期来看，工作的时间越长，效率是越低的，这里就涉及到一个拖延症，总想着任务可以在晚上还有时间可以解决，导致每个成员心理有个念头。拖延症毛病越来越严重，就算给你再多时间，也可能无法按时完成任务. 如果时间控制的刚好，那么每个人做事的起来就会速度很多，导致他自身能力也会提高，他能力的提高不仅对他个人，提升整个团队士气和水平是最关键的。加班这东西本身就是个破坏别人生活的事情，更多的要营造一个工作成为生活的一部分的环境。这个才是关键。</p>
<p>上面只是蜻蜓点水的说了下建立团队中的招聘和成员效率的一些可能你会碰到的问题，当然如果你愿意和我细细交流，可以留言。 很多事情不是只言片语就可以描述的。</p>
<hr>
<blockquote>
<p>无论你身处何方，无论是四分之一英里的赛道，还是绕了大半个地球的距离。我们生命中最重要的东西就是这屋檐下的人，就在此时，就在此地，你永远在我身边，也永远是我的兄弟 ！ </p>
</blockquote>
<p>我所期望的团队成员应该具备：</p>
<p>价值观一致、责任感、能力相差不大、成员之间优势互补、再加一句称不上 “出生入死” 但应该是 “同舟共济” 。</p>
<p>始终相信，只要团队不散，一个项目即使失败，大不了再起一个项目. </p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erbawp9g2ij20di04v3z4.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今晚是第二遍看速7，不仅被剧情吸引，更被这样的团队所吸引， 或许是因为看到团队成员中自己的影子。</p>
<p>近期一直在忙着招聘的事，说实话，这真是个非常花精力的事情，而且你必须投入进去，因为没人会帮你去做，况且别人认为合适的，自己却不一定觉得他合适. 因为你们之间看到的点和面都可能不一样, 我看重的是他的综合能力如何，潜力，是否在团队中起个重要的角色等，别人看到的是可能是经验如何，性价比是否高…<br>]]>
    
    </summary>
    
      <category term="venture-road" scheme="http://vimer.me/categories/venture-road/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[疯狂创业路（二）：14年末微传播失败--手写字祝福贺卡(书心)]]></title>
    <link href="http://vimer.me/2015/04/startup-2-14year-shuxin-failed/"/>
    <id>http://vimer.me/2015/04/startup-2-14year-shuxin-failed/</id>
    <published>2015-04-11T05:52:48.000Z</published>
    <updated>2015-11-23T05:52:12.000Z</updated>
    <content type="html"><![CDATA[<p>14年7月份左右，一个叫“围住神经猫”的H5的游戏在微信刷屏…此后, 这种传播方式被认为是’性价比最高’的方式.</p>
<p>14年末的时候，也就是情人节和新年快到的时候，我们也是脑袋一拍，制作个新年手写送祝福如何 ? 几个人稍微讨论下，我就开始写了，一个人大概断断续续花了两周时间(创业就是这样, 期间还有其他事情，永远不可能纯粹)， 最后上线的时候通宵了两晚，终于上线了.<br><a id="more"></a></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1er1ku109xkj20hs0vkdhb.jpg" width="50%" height="80%"><br><img src="http://ww4.sinaimg.cn/large/744e593bgw1er1ktduayoj20hs0vktaq.jpg" width="50%" height="80%"><br><img src="http://ww2.sinaimg.cn/large/744e593bgw1er1lapv0cdj20hs0vk0vx.jpg" width="50%" height="80%"></p>
<p>javascript模拟毛笔字核心算法已开源:<br><a href="https://github.com/vimer/handWritingWithJS" target="_blank" rel="external">handWritingWithJS</a></p>
<p>上线后发现根本不是我们想的那样, 也就公司几个人在帮忙宣传传播着，但是几乎很难看到朋友圈其他人在分享. </p>
<p>私下沟通了一些朋友, 原因主要是两点:</p>
<ol>
<li>自己的字本身写的不好, 不愿意分享的占 80% </li>
<li>不知道写些什么</li>
<li>喜欢1对1发送给朋友</li>
</ol>
<p>所以这次尝试短期而言可以说是失败的，当时选择这个切入是没错的， 但是产品是有问题的.</p>
<p>首先，微信上容易被大家传播的通常是那种简单粗暴风格的, 不用大家费多少脑筋，且有对比数据，让大家形成攀比. 而我们这个，得要求你写字好看，才能让自己觉得舒服, 才会去分享. 所以写字本身没错, 但是不要过于追求字的真实还原度，可以让写出的字都比较好看，然后人与人之间也能形成差异. 更重要的一点是不要让应用学习成本增加，一定要易上手. 如果把APP的内容搬到这里来不是不可以，而是为了做推广，就不适合这样.</p>
<p>其次, 如果写一个字还好, 让用户去写一段字, 又是比较费劲的事, 比如足记，用户可以自己写，也可以直接选现成的. 这一点上其实是犯了一个产品设计的大错, 千万不要在这种适合交给用户太多空间. </p>
<p>最后我想说一句, 任何产品想一日爆红的念头是非常愚蠢的, 中国人创业很多都有赌徒心态, 没有踏踏实实做好产品的心态.这几天接触股票, 说句实在话, 想创业就不要炒股, 反之亦然… </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>14年7月份左右，一个叫“围住神经猫”的H5的游戏在微信刷屏…此后, 这种传播方式被认为是’性价比最高’的方式.</p>
<p>14年末的时候，也就是情人节和新年快到的时候，我们也是脑袋一拍，制作个新年手写送祝福如何 ? 几个人稍微讨论下，我就开始写了，一个人大概断断续续花了两周时间(创业就是这样, 期间还有其他事情，永远不可能纯粹)， 最后上线的时候通宵了两晚，终于上线了.<br>]]>
    
    </summary>
    
      <category term="venture-road" scheme="http://vimer.me/categories/venture-road/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[疯狂创业路（一）：24pi - 团队合作才能大作, 这是种胸怀]]></title>
    <link href="http://vimer.me/2015/03/startup-1-24pi-tearm-will-be-great/"/>
    <id>http://vimer.me/2015/03/startup-1-24pi-tearm-will-be-great/</id>
    <published>2015-03-08T06:34:48.000Z</published>
    <updated>2015-11-23T05:52:07.000Z</updated>
    <content type="html"><![CDATA[<p>直接从大三的创业项目过渡目前这个创业, 来的的确有点快, 本来想一一娓娓道来，但24pi这个产品牵动着核心成员及几十万粉丝的心，请允许我写个总结. 之前的创业产品和项目一些靠谱经验会慢慢补上.</p>
<h3 id="一、产品">一、产品</h3>
<h4 id="1-需求分析">1.需求分析</h4>
<p>首先24pi在需求分析上做的不好，那时就是一个idea，飘飘洒洒发散了一下，就抗几把枪开始干了. 导致后来走了一段弯路, 还好发现的时候开发的周期不长, 变道比较快，如果已经开发了很长一段时间了，那么成本就上去了。 所以需求分析必须重视  !</p>
<p>需求分析阶段我的建议是多次头脑风暴来不断细化产品. 不断庖丁解牛，对于细化产品得粒度及广度是和几个核心人员的经验有关的, 如果第一次你可以尝试从调查目标人群、 自己身边普通用户进行黑箱调查… 切忌拍脑袋做产品.<br><a id="more"></a></p>
<h4 id="2-产品交互原型">2.产品交互原型</h4>
<p>这里要谈谈产品原型的重要性，产品原型制作时间相比较开发时间是非常少的，但是又是非常接近于成品的一个东东，所以如果原型制作非常熟练建议还是必须先出原型，再不行直接草稿也行。最好得方式是先草稿，设计根据草稿做出设计图，然后再出整个产品原型交互原型，整个过程控制在非常短得时间内，如果和大家协商没问题就可以开发了。不然你会发现开发人员不停的在需求上进行改动，一会加，一会不加… </p>
<h4 id="3-产品迭代周期">3.产品迭代周期</h4>
<p>由于互联网的变化速度之快, 建议每周迭代一个版本, 周五开发结束，周末测试, 周一发布.</p>
<h4 id="4-试错">4.试错</h4>
<p>试错对于任何的产品都会有, 这里我强调的是快而准, 快和准是和上一条迭代周期有关的, 每发布一个迭代版本，定会有即时用户反馈和功能统计数据, 根据这些在初心不变的情况下做一些小步更改. 当然如果大方向发现有问题要立即停止.</p>
<p>另外提醒下:有些事试错成本远大于事后获取的经验值,更多时候需要的是自己的一份睿智而不是经验.</p>
<h4 id="5-头脑风暴">5.头脑风暴</h4>
<p>对于头脑风暴, 我建议两周一次, 主要用于核心成员对于产品方向的总结和信息对称.还有一个是成员之间信心的互相支撑.</p>
<h4 id="5-做好产品,切忌浮躁">5.做好产品,切忌浮躁</h4>
<p>其实世间不会亏待你的努力的, 开始我认为得到第三方应用市场推荐需要花钱, 后来我错了, 因为等我们上线几周后,在没有推广的情况下, 最美应用、小米市场等第三方都给与了推荐.这对我们来说已经是不小的精神上支持了.<br><img src="http://ww3.sinaimg.cn/bmiddle/744e593bjw1emxi1ic0vnj20f00qomzx.jpg" alt="最美"><br><img src="http://ww1.sinaimg.cn/bmiddle/744e593bgw1emt68iga1ij20t20f3q5o.jpg" alt="小米"></p>
<p>所以我觉得，如果你的产品需要广告或者需要营销人员去推销,就说明你的产品还不够好,科技应用于商业应该主打产品开发，而不是分销. 只要用心做一件事, 包括产品, 定会有人帮你的产品说话的.(这里不是强调不需要运营,其实运营和产品同样重要,这里只是说要强化产品)</p>
<h3 id="二、技术">二、技术</h3>
<p>其实技术对于移动互联网创业这块是个非常重要的一环. 问题很多 .</p>
<p>对于初创公司在开发速度上不仅仅要快，更重要一点是要更多得构建基础框架，为之后的开发节省更多时间成本. 这件事需要技术负责人必须做. </p>
<p>这里只强调技术负责人的角色, 因为一个领导者不仅仅是个称号。而是一个责任 !!</p>
<p>当产品原型出来后，下面一步是技术负责人做的事，必须拆解产品，让需求功能化，哪些能做，哪些更容易做，哪些不能做，技术怎么选型，制定开发周期，督促整个开发周期，协调开发人员，技术难点突破，技术文档实现，技术标准等等都是的. 不是仅仅安排事这简单.</p>
<p>其实还包含团队的技术氛围、团队成员的能力提升等软性方面的，如果想做个称职得技术负责人这些都是必须要做且要做好的 !</p>
<p>我觉得让一个成员喜欢上这里，不是因为薪资，而是因为爱这里，这段经历可以让他提高自己,这个才是他拥有的财富.</p>
<h3 id="三、用户">三、用户</h3>
<p>对于用户，我喜欢用粉丝这词. 而且现在团队成员也渐渐喜欢用粉丝代替用户.<br>我个人比较喜欢或者说非常喜欢和粉丝打交道，我觉得一个做产品的人不和粉丝打交道那么产品肯定是做不好的. 因为粉丝是最初的需求来源 。他们得需求可能不是他们真正想要的, 但是你可以思考用户背后的真正需求. </p>
<blockquote>
<p>对于粉丝我觉得一定要善于运营, 和传统的运营区别在于, 四个字 “以情动情”<br>只有真诚的对待用户, 用户也会真诚*10倍得对待你, 或许这就是小米所说得参与感. </p>
</blockquote>
<p>下面两张是其中两个粉丝对24pi的评价.<br><img src="http://ww3.sinaimg.cn/large/744e593bgw1epyb1n4t0rj20al0dgdhf.jpg" alt="努力"></p>
<p><img src="http://ww3.sinaimg.cn/large/744e593bgw1epyb3zj28wj20au0e9jsq.jpg" alt="努力"></p>
<p>有人觉得和用户沟通是客服的事, 应该招个人或者让运营的人来专门负责这个事, 对于这种观点我不赞同, 如果这个事是大公司还可以理解，对于初创公司，尤其种子用户阶段，这件事必须亲力亲为.况且不用花太多时间, 需要的只是坚持.</p>
<p>我喜欢他们.</p>
<h3 id="三、团队">三、团队</h3>
<p>团队 !</p>
<p>标题说了, 团队合作才是大作, 这是种胸怀 .</p>
<p>以前我一直觉得自己适合且擅长一个人作战 ! 自己一个顶3-5人是没问题的，所以之前的创业大部分是我1个技术再加其他运营、产品等等. </p>
<p>不过我现在思路有改变，我的想法是自己一个人作战是错误的, 但是也不适合和普通人(对技术没感觉，效率比较低)一起作战. 因为所谓木桶的短板效应, 一个桶的水的多少还是和最短得板有关系，还有一点是和技术不在一个水平线的人共事协调起来非常费时费力. 宁愿自己抗起他那部分任务对我来说只不过是多写会代码的事, </p>
<p>所以这边要说的是团队成员的招聘.</p>
<p>对于初创公司，招聘这件事是最头疼的一件事, 尤其在核心成员还没全部出现得时候, 最好得建议是多花时间招人. 招聘渠道最靠谱的是从自己身边找 . 身边的好友等等. 只有把头几个核心成员凝聚起来, 这个就像个风眼, 周边的风暴会围绕这个风眼来聚起来, 而且越聚越大 .</p>
<p>团队核心成员的聚集关键在于价值观的统一, 价值观如果统一那么其他条件都是次要的,  这里我强调价值观. 什么是价值观,  这里最重要一点是目标统一 ! 在关键时刻尤其公司缺钱时能共患难. 这样的团队就算还没作品，VC也会欣赏的.</p>
<p>对于团队还有一点要说的是团队成员的融入. 这一点是我们要改善的地方.  关于融入最直接的是提高成员的积极性. 那么如何提高积极性我思考了几点:</p>
<ul>
<li>让开发人员体验式开发, 重点在于参与感, 体验产品开发的后获取的成就感</li>
<li>提升成员技能, 让他每周都能学到东西, 而不是机械式的开发. 这里强调分享会 和 团队成员之间的协助</li>
<li>多和成员进行沟通, 不要拘泥于形式 可以在一起走路时多沟通最近想法 这个话题可以围绕工作  生活 学习 展开 从这些可以预判成员的行为. </li>
</ul>
<p>对于团队成员的离开, 我觉得没必要去担心, 可以用朱念洋的一句话总结下: “走了得人, 公司后面是成是败, 也都与你无关。 留下来的, 当年咋们共苦, 成了咋们共甘.”</p>
<h3 id="四、协作">四、协作</h3>
<p>对于团队协作我倾向于大家能够互相push对方(当时我只知道“敏捷开发”这个词而没有过多的了解他) 后来了解到Scrum, 引入了周会和每天站会。所谓敏捷就是要提高开发效率,这个开发效率就是为了保证产品的快速迭代.我们是每周必须迭代一个版本,这样可以让用户知道我们一直在更新这款软件(就算用户很少,也得做)我们用心在改进.<br>这里推荐teambition做敏捷开发的管理平台.</p>
<h3 id="五、对于加班">五、对于加班</h3>
<p>我是很愿意把自己的青春奉献给自己喜欢做得事情,想必大家也一样,但是如果无畏着为了加班而加班,我是非常不赞同的.很长一段时间我们团队就存在这样毛病,最后形成每天大家都是20-22点才下班.把工作当做人生意义的一部分但不是全部.</p>
<h3 id="六、关于打卡">六、关于打卡</h3>
<p>对于技术团队,我是非常讨厌打卡的,对于这件事肯定很多人和我一样,但是如果从公司角度考虑还是有必要的,前面我说道不是每个人都能自我约束自己,打卡可以起到一定的警惕作用。(不要把考勤和工资挂钩就好),当然最好的方式是弹性工作制, 去掉打卡必须首先工程师得自律.</p>
<h3 id="七、创业场所">七、创业场所</h3>
<p>其实我觉得最好得创业场所是两层楼上面可以住下面是可以办公和运动的. 公司里面可以住不仅仅是吃苦问题，而是减少花在来回家和公司之间的时间成本. 不用折腾. 创业在拼得时候更应该是累了睡，休息好了继续 …<br>曾有几天为了快速把pi行榜上线，带了自己帐篷在公司里面睡了2天多<br><img src="http://ww1.sinaimg.cn/large/744e593bgw1epybmzhp0pj20h70gejt8.jpg" alt="帐篷"><br>其实根本不算什么, 如果公司可以洗澡我非常喜欢这样的生活. 我宁愿天天住公司.<br>另外还强调一点是 公司需要给成员提供必备的运动环境或者时间. 因为健康永远是第一的. 如果长期不运动这么拼得搞事业 很容易把自己身体搞垮的，得不偿失，有张有弛才是, 这里不分创业公司和上市公司, 只要是公司这种条件提供是应该的.</p>
<p>虽然目前的创业场所不是特别合适我, 但已经不错了，坐落在黄浦江边. 平时可以眺望下.<br><img src="http://ww4.sinaimg.cn/large/744e593bgw1epybvgq33yj20vk0no78i.jpg" alt="环境"></p>
<h3 id="八、对于自己">八、对于自己</h3>
<p>一直认为自己善于管理，尤其善于观察他人的心理 . 但是自己短板在于是懒得沟通.  对, 是 “懒”! 因为自己以前一直在做技术,  天天和计算机用0和1沟通, 把自己所负责的事情发挥到极致. 这是以前喜欢做的. 现在更多得要担起公司的责任. 从公司整体利益出发, 所以 让自己沟通起来 ! </p>
<p> 这里说到沟通, 不得不说一句, 一定是有效的沟通, 而不是废话. 我不喜欢“说的多,看的多, 做的比较少得人” ，  而且永远不喜欢. 所以自己肯定不会往这方面发展,  我希望自己能尽量一句话表达自己观点, 或者用尽量简短得话来说事, 大部分时间还是放在执行上.</p>
<p>最后对自己说一句: 对坚持最大的鼓励,不是“你可以”, 而是多年后说一句:”还好你没放弃”.</p>
<p>另外,团队不断招人 , 只要你认同我价值观, 只要你足够优秀. 把简历砸过来吧.<br>Android，iOS，后端, 设计…<br>emacs#vimer.org</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>直接从大三的创业项目过渡目前这个创业, 来的的确有点快, 本来想一一娓娓道来，但24pi这个产品牵动着核心成员及几十万粉丝的心，请允许我写个总结. 之前的创业产品和项目一些靠谱经验会慢慢补上.</p>
<h3 id="一、产品">一、产品</h3>
<h4 id="1-需求分析">1.需求分析</h4>
<p>首先24pi在需求分析上做的不好，那时就是一个idea，飘飘洒洒发散了一下，就抗几把枪开始干了. 导致后来走了一段弯路, 还好发现的时候开发的周期不长, 变道比较快，如果已经开发了很长一段时间了，那么成本就上去了。 所以需求分析必须重视  !</p>
<p>需求分析阶段我的建议是多次头脑风暴来不断细化产品. 不断庖丁解牛，对于细化产品得粒度及广度是和几个核心人员的经验有关的, 如果第一次你可以尝试从调查目标人群、 自己身边普通用户进行黑箱调查… 切忌拍脑袋做产品.<br>]]>
    
    </summary>
    
      <category term="venture-road" scheme="http://vimer.me/categories/venture-road/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MongoDB Map-Reduce 原理及提速]]></title>
    <link href="http://vimer.me/2015/01/mongodb-map-reduce-increase-speed/"/>
    <id>http://vimer.me/2015/01/mongodb-map-reduce-increase-speed/</id>
    <published>2015-01-18T04:07:42.000Z</published>
    <updated>2015-11-23T05:58:51.000Z</updated>
    <content type="html"><![CDATA[<p>想要优化Map-reduce就要深入理解其原理.</p>
<p>Map-Reduce基本原理请见下图:</p>
<a id="more"></a>
<p><img src="http://ww4.sinaimg.cn/large/744e593bgw1eodjvvjkrij20r80jgdj7.jpg" alt="Map-Reduce基本原理"></p>
<p>整个数据处理流程可以参见官方上图,先对要进行处理的数据进行Query,然后针对Query的数据进行map,最后针对map的数据进行reduce.</p>
<p>简单了解之后,我们这里取一个例子熟悉下整个过程:</p>
<p>数据基本格式为:</p>
<pre>
<code class="js">
/* 0 */
{
    "code" : "A",
    "uid" : "id_1",
    "count" : 1
}

/* 1 */
{
    "code" : "A",
    "uid" : "id_1",
    "count" : 1
}

/* 2 */
{
    "code" : "B",
    "uid" : "id_1",
    "count" : 1
}

/* 3 */
{
    "code" : "B",
    "uid" : "id_2",
    "count" : 2
}
</code>
</pre>

<p>目的:根据uid计算出count的和 且 这个合涉及到哪些code.</p>
<p>很快就可以写出Map和Reduce函数:</p>
<pre>
<code class="javascript">
var map = function() {
    emit(this.uid, {"code":this.code || "", count:this.count || 1});
};

var reduce = function(key, values) {
    var result = {code:{}, count:0};
    values.forEach(function(val) {
                result.code[val.code] = 1;
                result.count += val.count;
                });
    return result;
}
</code>
</pre>

<p>结果为:</p>
<pre>
<code class="javascript">
/* 0 */
{
    "_id" : "id_1",
    "value" : {
        "code" : {
            "A" : 1,
            "B" : 1
        },
        "count" : 3
    }
}

/* 1 */
{
    "_id" : "id_2",
    "value" : {
        "code" : "B",
        "count" : 2
    }
}
</code>
</pre>

<p>这次我省去了query的过程,直接进行Map和Reduce,我们来拆解下过程:</p>
<p>首先,MongoDB会扫描整个数据表(这里省去Query)遍历所有documents,对于每个docuemnt都会根据key(uid)进行map存储.</p>
<p>其次,这个时候MongoDB会对记录的size进行检查( mongod checks every 100 records that the size of the map is not over 50KB, if so it runs reduce on ALL current keys. If size of map is still over 100KB, it dumps all current documents to disk in an “incremental” collection.)</p>
<p>最后根据map的数据进行reduce操作.</p>
<p>好,上面三点是大概的过程,对于Mapping过程,上面实例中会进行</p>
<pre>
<code class="javascript">
{"id_1", values:[{"code":"A", "count":1}, {"code":"A", "count":1}, {"code":"B", "count":1}}
</code>
</pre>

<p>这样的Emit操作.这点是需要注意的.然后以这样得方式传入到Reduce进行处理,所以Reduce必须对values进行forEach处理.</p>
<p>通过上面这个过程,还有一点要非常注意:如果有很多文档,而且这些文档的分布是非常随机的,当内存比较小时,MongoDB会采取把这些数据存在一个inc自增的文档中.</p>
<p>比方说:我有A, B, C三个key, 每个key有100个, 但是这些key都是随机分布的 比如A…B…A…B..C…A..B..C..当我要先对A进行Emit时需要把所有是A的key的document获取出来,那么这个过程当内存很小时 需要把大部分得document存储到磁盘上.然后内存和磁盘一直交换数据,至到把A全部找出为止(期间每在内存中操作的部分A会先Emit出去).</p>
<p>这种操作肯定很耗时, 如果我们对key进行索引且排好序,那么排好序的A就会大部分在内存中,减少了内存和磁盘的切换次数.</p>
<p>所以对大数据加排序是必须要有的.这个细节至少可以提高很多倍得处理速度.</p>
<p>基本原理先说到这,还有更多实践干货留着下次说.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>想要优化Map-reduce就要深入理解其原理.</p>
<p>Map-Reduce基本原理请见下图:</p>
]]>
    
    </summary>
    
      <category term="Map-Reduce" scheme="http://vimer.me/tags/Map-Reduce/"/>
    
      <category term="MongoDB" scheme="http://vimer.me/tags/MongoDB/"/>
    
      <category term="tech" scheme="http://vimer.me/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js异步回调池, Maximum call stack size exceeded error]]></title>
    <link href="http://vimer.me/2015/01/rangeerror-max-call-stack-size-exceeded-error/"/>
    <id>http://vimer.me/2015/01/rangeerror-max-call-stack-size-exceeded-error/</id>
    <published>2015-01-17T08:12:17.000Z</published>
    <updated>2015-11-23T05:59:51.000Z</updated>
    <content type="html"><![CDATA[<p>这种错误主要发生在js调用栈的限制,如下面递归调用的代码:</p>
<pre>
<code class="javascript">
(function a() {
    a();
})();
</code>
</pre>

<p>但是在Node.js中除了因为调用栈限制导致这种错误,还会因为异步回调的池满了导致这个问题,正常来说每个异步函数调用的回调函数,基本都是由事件触发回调的,这些事件触发器存在于一个地方,异步回调完成后,这个内存才会被回收.<br><a id="more"></a></p>
<p>比如下面这种代码:</p>
<pre>
<code class="javascript">
for (var i=0;i< docs.length; i++) {
    mongo.test.insert(docs[i], function(err, docs) {
        //....
    });
}
</code>
</pre>

<p>如果length=10000,瞬间发起这么多个异步操作,异步回调池肯定就满了,但是如果这些异步操作,1个完成之后发起下一个,这样池肯定没问题.</p>
<p>解决这种问题得方法:</p>
<blockquote>
<p>1.可以使用队列批量回调,限制在回调池大小之内<br>2.同步每一个回调</p>
</blockquote>
<p>有两个现成得module可以解决这种问题:</p>
<pre>
<code class="nodejs">
/*bagpipe*/
var async = function(val, callback) {
    setTimeout(function() {}, 1000);
}
var bagpipe = new Bagpipe(500);
for (var i=0; i< docs.length; i++) {
    bagpipe.push(async, docs[i].value, function(callback) {

    });
}

/*async*/
var q = async.queue(function(task, callback) {
    setTimeout(function() {
        log.info(task);
        callback(null, {});
    }, 5000);
}, 10);
q.drain = function() {
    log.info("finish");
}
for (var i=0; i< 100; i++) {
    q.push(i, function(err, data) {

    });
}
</code>
</pre>

]]></content>
    <summary type="html">
    <![CDATA[<p>这种错误主要发生在js调用栈的限制,如下面递归调用的代码:</p>
<pre>
<code class="javascript">
(function a() {
    a();
})();
</code>
</pre>

<p>但是在Node.js中除了因为调用栈限制导致这种错误,还会因为异步回调的池满了导致这个问题,正常来说每个异步函数调用的回调函数,基本都是由事件触发回调的,这些事件触发器存在于一个地方,异步回调完成后,这个内存才会被回收.<br>]]>
    
    </summary>
    
      <category term="Node.js" scheme="http://vimer.me/tags/Node-js/"/>
    
      <category term="异常" scheme="http://vimer.me/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="tech" scheme="http://vimer.me/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js和cpu密集型计算]]></title>
    <link href="http://vimer.me/2014/12/nodejs-cpu-cal/"/>
    <id>http://vimer.me/2014/12/nodejs-cpu-cal/</id>
    <published>2014-12-27T11:35:46.000Z</published>
    <updated>2015-11-23T05:59:13.000Z</updated>
    <content type="html"><![CDATA[<pre>
<code class="javascript">
setTimeout(function () {
    for (var i = 0; i < 10000000000; i++) {
        //CPU密集
    }
}, 200);

setTimeout(function () {
    console.log('210 ms...');
}, 210);
</code>
</pre>

<p>这个小例子很经典的解释了Node.js遇到密集型CPU的时候问题,这个程序分别在两个时间点触发,虽然在210ms得时候回调内得程序执行非常很快,但是在200ms得时候处理了一个CPU非常密集型的任务就导致整个线程阻塞了.<br><a id="more"></a> </p>
<p>至于Event Loop机制可以参考:<br><a href="http://www.infoq.com/cn/articles/nodejs-weakness-cpu-intensive-tasks" target="_blank" rel="external">http://www.infoq.com/cn/articles/nodejs-weakness-cpu-intensive-tasks</a><br>这篇文章中关于<strong>Event Loop和Tick</strong>的一段:</p>
<blockquote>
<p>每个Node程序的主线程都有一个event loop，JavaScript代码全在这个单线程下运行。所有的I/O操作以及对本地API的调用，或者是异步的（借助程序所在平台的机制），或者运行在另外的线程中。这全都是通过libuv处理的。所以当socket上有数据过来，或本地API函数返回时，需要有种同步的方式调用对刚发生的这一特定事件感兴趣的JavaScript函数。</p>
<p>在发生事件的线程中直接调用JS函数是不安全的，因为那样也会遇到常规多线程程序遇到的问题，竞态条件、非原子操作的内存访问等等。所以要以一种线程安全的方式把事件放在队列中，如果写成代码，大致应该是这样的：</p>
</blockquote>
<pre>
<code class="c">
lock (queue) {
    queue.push(event);
}
</code>
</pre>

<p>然后在执行JavaScript的主线程中（即event loop的c代码）：</p>
<pre>
<code class="c">
while (true) {
    // tick开始
    lock (queue) {
        var tickEvents = copy(queue); 
        // 将当前队列中的条目复制的线程自有的内存中
        queue.empty(); // ..清空共享的队列
    }
    for (var i = 0; i < tickEvents.length; i++) {
        InvokeJSFunction(tickEvents[i]);
    }
    // tick结束
}
</code>
</pre>

<blockquote>
<p>while (true) (在真正的node源码中并不是这样的；这里只是为了说明)表示event loop。里面的for为队列中的每个事件调用JS函数。Event loop在每个tick中都会调用与外部事件相关联的零个或多个回调函数，一旦队列被清空，并且最后一个函数返回后，tick就结束了。然后回到开始（下一个tick），重新开始检查其它线程在JavaScript运行时加到队列中的事件。</p>
<p>那么这个队列中的东西都是谁放进来的呢？</p>
<p>process.nextTick<br>setTimeout/setInterval<br>I/O (来自fs、net等)<br>crypto中的CPU密集型函数，比如crypto streams、pbkdf2和PRNG<br>所有使用libuv工作队列异步调用C/C++库的本地模块<br>同样下面代码当调用t1接口时也会导致t2的接口变慢.</p>
</blockquote>
<pre>
<code class="nodejs">
 app.get("/t1", function* (next) {
    for (var i=0; i< 5000000000; i++) {
        //cpu密集型
    }
    console.log("t1");
});
app.get("/t2", function* (next) {
    console.log("t2");
});
</code>
</pre>

<p>这么看Node.js是否能够胜任cpu密集型操作呢,答案当然是否定的,Node.js虽然是单线程,但是可以开启多个Node.js实例来充分利用多核的优势,另外Node.js还支持子进程,通过子进程来计算.</p>
<h4 id="for-js">for.js</h4>
<pre>
<code class="javascript">
var calc = function() {
     for (var i = 0; i < 10000000000; i++) {
     }
}
process.on('message', function(m) {
  //接收主线程发来消息
     console.log("recv mesage");
     calc();
     process.send(1);
});
process.on('SIGHUP', function() {
          process.exit();//收到kill信息，进程退出
});
</code>
</pre>

<h4 id="main-js">main.js</h4>
<pre>
<code class="javascript">
var fork = require('child_process').fork;
setTimeout(function () {
    var worker = fork("./for.js");
    worker.on("message", function(m) {
        //接收工作进程的结果
        console.log("world");
        worker.kill();
    });
    worker.send(1);
}, 200);

setTimeout(function () {
  console.log('hello');
}, 210);
</code>
</pre>

<p>上面这个程序就是利用进程间来通信,for.js是子进程执行的密集型计算.main.js可以继续调度其他程序.充分利用了cpu.</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre>
<code class="javascript">
setTimeout(function () {
    for (var i = 0; i < 10000000000; i++) {
        //CPU密集
    }
}, 200);

setTimeout(function () {
    console.log('210 ms...');
}, 210);
</code>
</pre>

<p>这个小例子很经典的解释了Node.js遇到密集型CPU的时候问题,这个程序分别在两个时间点触发,虽然在210ms得时候回调内得程序执行非常很快,但是在200ms得时候处理了一个CPU非常密集型的任务就导致整个线程阻塞了.<br>]]>
    
    </summary>
    
      <category term="Node.js" scheme="http://vimer.me/tags/Node-js/"/>
    
      <category term="cpu密集型计算" scheme="http://vimer.me/tags/cpu%E5%AF%86%E9%9B%86%E5%9E%8B%E8%AE%A1%E7%AE%97/"/>
    
      <category term="tech" scheme="http://vimer.me/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nohup和SIGHUP信号]]></title>
    <link href="http://vimer.me/2014/12/nohup-sighup/"/>
    <id>http://vimer.me/2014/12/nohup-sighup/</id>
    <published>2014-12-26T03:30:46.000Z</published>
    <updated>2015-11-23T05:59:33.000Z</updated>
    <content type="html"><![CDATA[<p>为什么这篇文章会提到nohup呢,主要还是最近在使用了一个叫maptail东西,它可以根据nginx的日志中IP来把IP和具体地址进行转换并显示在中国地图上.这样可以实时的查看接口的调用情况.</p>
<a id="more"></a>
<p><img src="http://ww3.sinaimg.cn/large/744e593bgw1enmxnoxfulj20kk0fr41o.jpg" alt="24pi_maptail"></p>
<p>这里不讨论maptail,主要说得是maptail启用方式: </p>
<pre>
<code class="bash">
tail -f nohup.out | maptail -h my.host.com -p 3000 > /dev/null & 
</code>
</pre>

<p>这条命令运行了一段时间后,进程就总是不响应了,但是进程还在.</p>
<p>不禁让我们对nohup和SIGHUP做了个实验.(自己写博可能有些跳跃,不明白可以直接回复:)</p>
<pre>
<code class="bash">
tail -f 1 &
</code>
</pre>

<p>这样放入后台后,通过进程树可以看到</p>
<p><img src="http://ww1.sinaimg.cn/large/744e593bgw1enmy7tgiutj209q02sjrj.jpg" alt="tail进程树"><br>这个tail进程挂接在bash父进程上.</p>
<p>我们exit退出当前shell.再次进去看下:<br><img src="http://ww4.sinaimg.cn/large/744e593bgw1enmycasfnbj203f060wej.jpg" alt="tail进程树"><br>可见它被init进程来接管.</p>
<p>也就是这个进程运行正常,没什么问题.</p>
<p>那么nohup起了什么作用呢 ? </p>
<p>如果nohup起守护进程的作用,那么刚才这个进程也能正常运行于后台.</p>
<p>我们再用nohup来运行这个进程看看</p>
<pre>
<code class="bash">
nohup tail -f 2 &
</code>
</pre>

<p>按照上述操作,tail -f 2也同样跑在后台中.</p>
<p>nohup主要的作用是可以忽略SIGHUP信号,我们对上面两个进程分别进行发出kill -HUP 信号.</p>
<p>tail -f 2成功忽略了SIGHUP信号,而tail -f 1被成功杀死, 那么SIGHUP信号什么时候发出呢.</p>
<p>做了一些测试,关闭终端是不能发送SIGHUP给进程的.</p>
<p>当终端正常连接过程, 把笔记本合上, 过一段时间后, 发现tail -f 1被杀死了, 也就是说SIGHUP是终端连接断开时才发出的. 正常逻辑是: 当终端断开时,SIGHUP信号首先发给shell所在进程,而shell收到后,会向所有进程组发送SIGHUP信号,假设没有任何捕捉此信号，那么受到SIGHUP信号的进程就会关闭了, 而nohup守护的进程就不会.</p>
<p>当然如果遇到没有nohup进程已经运行,但是想把此进程离开当前进程组比如bash，可以借用distown这个命令.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>为什么这篇文章会提到nohup呢,主要还是最近在使用了一个叫maptail东西,它可以根据nginx的日志中IP来把IP和具体地址进行转换并显示在中国地图上.这样可以实时的查看接口的调用情况.</p>
]]>
    
    </summary>
    
      <category term="nohup" scheme="http://vimer.me/tags/nohup/"/>
    
      <category term="SIGHUP" scheme="http://vimer.me/tags/SIGHUP/"/>
    
      <category term="tech" scheme="http://vimer.me/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js原子性操作MongoDB]]></title>
    <link href="http://vimer.me/2014/12/howto-nodejs-atom-op-mongodb/"/>
    <id>http://vimer.me/2014/12/howto-nodejs-atom-op-mongodb/</id>
    <published>2014-12-21T12:47:06.000Z</published>
    <updated>2015-11-23T05:58:01.000Z</updated>
    <content type="html"><![CDATA[<p>假设基础数据为:</p>
<pre>
<code class="javascript">
{
    "name" : "cb",
    "data" : 0,
}
</code>
</pre>

<p>有时候为了充分利用多核,会同时开启多个node进程,但是若部分代码若涉及到操作mongodb就会有下面现象.<br>“理想情况下”,多个进程执行完后得数据为:</p>
<pre>
<code class="javascript">
{
    "name" : "cb",
    "data" : 6000,
}
</code>
</pre>

<p>其实不然 !<br><a id="more"></a></p>
<p>我们看看获得结果是怎么样的.</p>
<pre>
<code class="javascript">
co(function* () {
    for (var i=0; i< 3000; i++) {
        var getTest = yield mongoCtest.findOne({"name":"cb"}, {"fields":{"_id":0}});
        getTest.data =  getTest.data+1;
        console.log(getTest);
        yield mongoCtest.update({"name":"good"}, {"$set":getTest});
    }
})();
</code>
</pre>

<p>上面的程序同时开两个,多个进程同时操作一个数据.<br>可能结果会是:<br><img src="http://ww1.sinaimg.cn/large/744e593bgw1enhm3w6525j20wo0n6459.jpg" alt="多进程操作Mongo"></p>
<p>我们知道Mongo是不支持事务的,如果你能容忍上面的弱一致性,那么没问题.但是如果你不能容忍，要么考虑MySql关系型数据库,要么自己解决事务问题.</p>
<p>下面我来说下基于Mongo怎么解决事务问题.<br>我们需要对每个数据加一个version来控制.直接上代码:</p>
<pre>
<code class="javascript">
co(function* () {
    for (var i=0; i< 3000; i++) {
        while (1) {
            var getTest = yield mongoCtest.findOne({"name":"cb"}, {"fields":{"_id":0}});
            getTest.data =  getTest.data+1;
            var originalVer = getTest.ver;
            getTest.ver = getTest.ver+1;
            console.log(getTest);
            var ret = yield mongoCtest.update({"name":"cb", "ver":originalVer}, {"$set":getTest});
            if (ret)  break;
        }
    }
})();
</code>
</pre>

<p>下面就是我们想要的结果:)</p>
<p><img src="http://ww1.sinaimg.cn/large/744e593bgw1enhm5tgq6qj20xt0njqbo.jpg" alt="原子性控制"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设基础数据为:</p>
<pre>
<code class="javascript">
{
    "name" : "cb",
    "data" : 0,
}
</code>
</pre>

<p>有时候为了充分利用多核,会同时开启多个node进程,但是若部分代码若涉及到操作mongodb就会有下面现象.<br>“理想情况下”,多个进程执行完后得数据为:</p>
<pre>
<code class="javascript">
{
    "name" : "cb",
    "data" : 6000,
}
</code>
</pre>

<p>其实不然 !<br>]]>
    
    </summary>
    
      <category term="Node.js" scheme="http://vimer.me/tags/Node-js/"/>
    
      <category term="MongoDB" scheme="http://vimer.me/tags/MongoDB/"/>
    
      <category term="原子性" scheme="http://vimer.me/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
      <category term="tech" scheme="http://vimer.me/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[由 C 中字符串比较引入的问题]]></title>
    <link href="http://vimer.me/2012/07/c-string-question/"/>
    <id>http://vimer.me/2012/07/c-string-question/</id>
    <published>2012-07-19T14:27:45.000Z</published>
    <updated>2015-11-23T05:55:21.000Z</updated>
    <content type="html"><![CDATA[<p>一个同事在Project中写下如下错误代码(为了说明问题, 代码已经简写)</p>
<pre>
<code class="C">
void function(const char* _str) {
    if (_str == "OK") {

    }
}
</code>
</pre>

<p>这段代码 错就错在把char*(从堆里分配的)字符串直接 常量字符串进行比较.<br>而这位同事不解的拿出下面这个例子对我发出这样的疑问:为什么会这样?</p>
<a id="more"></a>
<pre>
<code class="C">
#include < stdio.h>
int main(int argc, const char** argv)
{
    char str_1[6] = "Crazy1";
    char* str_2 = "Crazy2";
    if (str_1 == "Crazy1") {
        printf("%s\n", "字符数组OK");
    }
    if (str_2 == "Crazy2") {
        printf("%s\n", "字符串常量OK");
    }

    return 0;
}
</code>
</pre>

<p>输出结果: 字符串常量OK</p>
<p>大部份人认为只有C++的String类才能执行等于比较符号操作, 而C中需要使用strcmp来进行”字符串”比较, 为什么这段程序告诉我们字符串常量是可以的, 而字符数组是不可以的. 这里其实主要是字符数组和字符串常量的区别,至于它们本质区别就不多说了, 比如一个存储在静态存储区, 一个在栈上分配空间…</p>
<p>这里主要要知道 str_2是指针, 指向”Crazy2″这个字符串常量的内存首地址,  而str_1是在栈里分配的字符数组”Crazy1″的首地址.</p>
<p>我们更深一步来解释这个问题:</p>
<p>咱们反汇编这段代码:</p>
<pre>
<code class="C">
.section .rodata
.LC0:
.string "Crazy2"
.LC1:
.string "OK"
.text
.globl main
.type main, @function
main:
pushl %ebp
movl %esp, %ebp
andl $-16, %esp
subl $32, %esp
movl $2053206595, 22(%esp)
movw $12665, 26(%esp)
movl $.LC0, 28(%esp)
cmpl $.LC0, 28(%esp)
jne .L2
movl $.LC1, (%esp)
call puts
.L2:
movl $0, %eax
leave
ret
.size main, .-main
.ident "GCC: (GNU) 4.5.1 20100924 (Red Hat 4.5.1-4)"
.section .note.GNU-stack,"",@progbits
</code>
</pre>

<p>咱们根据这段汇编代码可以看出 字符串常量是在编译时就确定的, 而字符数组是在运行时确定的.</p>
<pre>
<code class="C">
movl $.LC0, 28(%esp)
cmpl $.LC0, 28(%esp)
</code>
</pre>

<p>这2句可以直接看出 字符串常量的比较是怎么运算的.</p>
<p>而字符数组为什么不行呢? 很显然 因为他们不属于同一个内存空间.</p>
<blockquote>
<p>建议: C字符串比较都使用strcmp</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个同事在Project中写下如下错误代码(为了说明问题, 代码已经简写)</p>
<pre>
<code class="C">
void function(const char* _str) {
    if (_str == "OK") {

    }
}
</code>
</pre>

<p>这段代码 错就错在把char*(从堆里分配的)字符串直接 常量字符串进行比较.<br>而这位同事不解的拿出下面这个例子对我发出这样的疑问:为什么会这样?</p>
]]>
    
    </summary>
    
      <category term="C" scheme="http://vimer.me/tags/C/"/>
    
      <category term="字符串" scheme="http://vimer.me/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="tech" scheme="http://vimer.me/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MONGODB的BASIC INDEXES 和 COMPOUND INDEXES 研究]]></title>
    <link href="http://vimer.me/2012/07/mongodb-basic-indexes-compound-indexes/"/>
    <id>http://vimer.me/2012/07/mongodb-basic-indexes-compound-indexes/</id>
    <published>2012-07-11T17:18:41.000Z</published>
    <updated>2015-11-23T05:58:27.000Z</updated>
    <content type="html"><![CDATA[<p>前几天看到一个关于 MongoDB 深入索引的PPT</p>
<p><a href="http://www.slideshare.net/mongodb/mongodb-indexing-the-details" target="_blank" rel="external">MongoDB Indexing: The Details</a></p>
<p>仔细的从头看到尾, 里面有个关于Compound Indexes的Range and Equality的讲解,在ppt第129页,重新回顾下这个例子.向一个collection中插入 9 条数据,像下面这样:</p>
<pre>
<code class="javascript">
> db.good.find()
{ "_id" : ObjectId("4e8d629d8ad8bdf2ed6c1990"), "x" : 1, "y" : "b" }
{ "_id" : ObjectId("4e8d62a38ad8bdf2ed6c1991"), "x" : 3, "y" : "d" }
{ "_id" : ObjectId("4e8d62ad8ad8bdf2ed6c1992"), "x" : 4, "y" : "g" }
{ "_id" : ObjectId("4e8d62b28ad8bdf2ed6c1993"), "x" : 5, "y" : "c" }
{ "_id" : ObjectId("4e8d62ba8ad8bdf2ed6c1994"), "x" : 6, "y" : "a" }
{ "_id" : ObjectId("4e8d62c18ad8bdf2ed6c1995"), "x" : 7, "y" : "e" }
{ "_id" : ObjectId("4e8d62ce8ad8bdf2ed6c1996"), "x" : 8, "y" : "c" }
{ "_id" : ObjectId("4e8d62d38ad8bdf2ed6c1997"), "x" : 9, "y" : "f" }
{ "_id" : ObjectId("4e8d719a6cee6416a5a75a43"), "x" : 5, "y" : "d" }
</code>
</pre>
<a id="more"></a>

然后给x 和 y进行联合索引
<pre>
<code class="javascript">
db.good.ensureIndex({x:1,y:1})
</code>
</pre>

<p>我们来进行这样的查找</p>
<pre>
<code class="javascript">
> db.good.find({x:{$gte:4}, y:’c’}).explain()
{
    "cursor" : "BtreeCursor x_1_y_1",
        "nscanned" : 7,
        "nscannedObjects" : 2,
        "n" : 2,
        "millis" : 0,
        "nYields" : 0,
        "nChunkSkips" : 0,
        "isMultiKey" : false,
        "indexOnly" : false,
        "indexBounds" : {
            "x" : [
                [
                    4,
                    1.7976931348623157e+308
                ]
            ],
            "y" : [
                [
                    "c",
                    "c"
                ]
            ]
        }
}
</code>
</pre>

<p>可以看出 nscanned 非常高! 而 n只有 2 .官网上有这样一句话:</p>
<blockquote>
<p>If nscanned is much higher than nreturned, the database is scanning many objects to find the target objects. Consider creating an index to improve this.</p>
</blockquote>
<p>这里nscanned可以认为是扫描的记录数.n为返回的记录数</p>
<p>让我们配合PPT看下 nscanned:7是怎么来的:</p>
<p><img src="http://ww3.sinaimg.cn/large/744e593bgw1end6qzl43vj20fy09t0ta.jpg" alt="BTree"></p>
<p>这是MongoDB的B-tree索引树,因为x&gt;=4 &amp;&amp; y=’c’,所以先选择左枝搜索,左枝搜索了4/g 和 5/c ,(5/c符合条件),然后搜索 右枝 搜索了 7/e, 6/a ,8/c, 9/f ,(8/c符合条件). 任何 符合的 x都要被check一下.</p>
<h3 id="延伸">延伸</h3>
<p>看了PPT后到此结尾了, 真遇到这种情况,效率可不乐观,于是稍微思考了下, y 在 这颗树中只有两个节点含有,也就是说 既然是 ‘与’  那就只要先把 y 筛选出来 ,搜索次数就大大减半了 .</p>
<p>我们在 y 上再进行Basic Indexes 的建立.</p>
<pre>
<code class="javascript">
db.good.ensureIndex({y:1})
</code>
</pre>

<p>这样如果搜索时会先 搜索 y  ,也就只有2次搜索了.看下实际情况:</p>
<pre>
<code class="javascript">
> db.good.find({x:{$gte:4}, y:’c’}).explain()
{
    "cursor" : "BtreeCursor y_1",
        "nscanned" : 2,
        "nscannedObjects" : 2,
        "n" : 2,
        "millis" : 0,
        "nYields" : 0,
        "nChunkSkips" : 0,
        "isMultiKey" : false,
        "indexOnly" : false,
        "indexBounds" : {
            "y" : [
                [
                    "c",
                    "c"
                ]
            ]
        }
}
</code>
</pre>

<p>正如预料的一样. 直接走 基本索引了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天看到一个关于 MongoDB 深入索引的PPT</p>
<p><a href="http://www.slideshare.net/mongodb/mongodb-indexing-the-details" target="_blank" rel="external">MongoDB Indexing: The Details</a></p>
<p>仔细的从头看到尾, 里面有个关于Compound Indexes的Range and Equality的讲解,在ppt第129页,重新回顾下这个例子.向一个collection中插入 9 条数据,像下面这样:</p>
<pre>
<code class="javascript">
> db.good.find()
{ "_id" : ObjectId("4e8d629d8ad8bdf2ed6c1990"), "x" : 1, "y" : "b" }
{ "_id" : ObjectId("4e8d62a38ad8bdf2ed6c1991"), "x" : 3, "y" : "d" }
{ "_id" : ObjectId("4e8d62ad8ad8bdf2ed6c1992"), "x" : 4, "y" : "g" }
{ "_id" : ObjectId("4e8d62b28ad8bdf2ed6c1993"), "x" : 5, "y" : "c" }
{ "_id" : ObjectId("4e8d62ba8ad8bdf2ed6c1994"), "x" : 6, "y" : "a" }
{ "_id" : ObjectId("4e8d62c18ad8bdf2ed6c1995"), "x" : 7, "y" : "e" }
{ "_id" : ObjectId("4e8d62ce8ad8bdf2ed6c1996"), "x" : 8, "y" : "c" }
{ "_id" : ObjectId("4e8d62d38ad8bdf2ed6c1997"), "x" : 9, "y" : "f" }
{ "_id" : ObjectId("4e8d719a6cee6416a5a75a43"), "x" : 5, "y" : "d" }
</code>
</pre>
]]>
    
    </summary>
    
      <category term="MongoDB" scheme="http://vimer.me/tags/MongoDB/"/>
    
      <category term="索引" scheme="http://vimer.me/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="tech" scheme="http://vimer.me/categories/tech/"/>
    
  </entry>
  
</feed>
